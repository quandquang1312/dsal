{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Template": {
		"prefix": "_template",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define int long long",
			"",
			"int32_t main() {",
				"",
				"\treturn 0;",
			"}"
		]
	},

	"Fenwick Tree": {
		"prefix": "_fenwick_tree",
		"body": [
		  "class FenwickTree {",
		  "public:",
		  "    FenwickTree(int n) {",
		  "        this->n = n;",
		  "        ft.assign(n, 0);",
		  "    }",
		  "",
		  "    FenwickTree(vector<int> arr) : FenwickTree(arr.size()) {",
		  "        for (int i=0; i<arr.size(); i++)",
		  "            add(i, arr[i]);",
		  "    }",
		  "",
		  "    int query(int l, int r) {",
		  "        return sum(r) - sum(l-1);",
		  "    }",
		  "",
		  "    void add(int idx, int vl) {",
		  "        for (; idx < n; idx = idx | (idx + 1))",
		  "            ft[idx] += vl;",
		  "    }",
		  "",
		  "private:",
		  "    vector<int> ft;",
		  "    int n;",
		  "",
		  "private:",
		  "    int g(int i) { return i & (i + 1); }",
		  "    int sum(int i) {",
		  "        int rs = 0;",
		  "        while (i >= 0) {",
		  "            rs += ft[i];",
		  "            i = g(i) - 1;",
		  "        }",
		  "        return rs;",
		  "    }",
		  "};",
		],
		"description": "Segment Tree"
	},

	"Segment Tree": {
		"prefix": "_segment_tree",
		"body": [
		  "#ifndef MAXN",
		  "#define MAXN 200100",
		  "#endif",
		  "",
		  "int arr[MAXN], st[MAXN*4];",
		  "",
		  "void build(int node, int l, int r) {",
		  "    if (l == r) st[node] = arr[l];",
		  "    else {",
		  "        int mid = (l+r) >> 1;",
		  "        build(node*2, l, mid);",
		  "        build(node*2+1, mid+1, r);",
		  "        // for sum segment tree",
		  "        st[node] = st[node*2] + st[node*2+1];",
		  "    }",
		  "}",
		  "",
		  "int query(int node, int l, int r, int tl, int tr) {",
		  "    if (l <= tl && tr <= r) return st[node];",
		  "    if (r < tl || tr < l) return 0; // for sum segment tree",
		  "    int mid = (tl+tr) >> 1;",
		  "    // for sum segment tree",
		  "    return query(node*2, l, r, tl, mid) + query(node*2+1, l, r, mid+1, tr);",
		  "}"
		],
		"description": "Segment Tree"
	},

	"Segment Tree Lazy Update": {
		"prefix": "_lazy_segment_tree",
		"body": [
		  "#define int long long",
		  "#define MAXN 200100",
		  "",
		  "int arr[MAXN], st[4*MAXN], lazy[4*MAXN];",
		  "",
		  "void push_lazy(int node)",
		  "{",
		  "    if (lazy[node])",
		  "    {",
		  "        st[node*2] += lazy[node];",
		  "        st[node*2+1] += lazy[node];",
		  "        lazy[node*2] += lazy[node];",
		  "        lazy[node*2+1] += lazy[node];",
		  "        lazy[node] = 0; ",
		  "    }",
		  "}",
		  "",
		  "void build(int node, int l, int r) {",
		  "    if (l == r) st[node] = arr[l];",
		  "    else {",
		  "        int mid = (l+r) >> 1;",
		  "        build(node*2, l, mid);",
		  "        build(node*2+1, mid+1, r);",
		  "        st[node] = min(st[node*2], st[node*2+1]);",
		  "    }",
		  "}",
		  "",
		  "int query(int node, int l, int r, int tl, int tr) {",
		  "    if (l <= tl && tr <= r) return st[node];",
		  "    if (r < tl || tr < l) return 1e15;",
		  "    int mid = (tl + tr) >> 1;",
		  "    push_lazy(node);",
		  "    return min(query(node*2, l, r, tl, mid), query(node*2+1, l, r, mid+1, tr));",
		  "}",
		  "",
		  "void update(int node, int l, int r, int tl, int tr, int x)",
		  "{",
		  "    if (r < tl || tr < l) return;",
		  "    if (l <= tl && tr <= r)",
		  "    {",
		  "        st[node] += x;",
		  "        lazy[node] += x;",
		  "        return;",
		  "    }",
		  "",
		  "    int mid = (tl + tr) >> 1;",
		  "    push_lazy(node);",
		  "    update(node*2, l, r, tl, mid, x);",
		  "    update(node*2+1, l, r, mid+1, tr, x);",
		  "    st[node] = min(st[node*2], st[node*2+1]);",
		  "}",
		  ""
		],
		"description": "Segment Tree Lazy Update"
	},

	"Difference Array": {
		"prefix": "_diff_array",
		"body": [
		  "#ifndef MAXN",
		  "#define MAXN 200100",
		  "#endif",
		  "",
		  "int n, arr[MAXN], diff[MAXN];",
		  "",
		  "void update(int l, int r, int vl) {",
		  "    diff[l] += vl;",
		  "    if (r + 1 < n) diff[r] -= vl;",
		  "}",
		  "",
		  "void apply_update()",
		  "{",
		  "    /*",
		  "    // update the value of arr by the prefix sum of diff",
		  "    */",
		  "    for (int i=0; i<n; i++) diff[i] += diff[i-1];",
		  "    for (int i=0; i<n; i++) arr[i] += diff[i]; ",
		  "}"
		],
		"description": "Difference Array"
	},

	"For loop": {
		"prefix": "_for",
		"body": [
			"for (int i=0; i<n; i++) {}",
		],
		"description": "Loop For"
	},

	"Binary Exponentiation": {
		"prefix": "_binpow",
		"body": [
		  "int binpow(int a, int b, int mod) {",
		  "    if (a == 0) return 0;",
		  "    if (b == 1) return a;",
		  "",
		  "    int res = 1;",
		  "    while (b) {",
		  "        if (b & 1) res = (res * a) % mod;",
		  "        a = a * a % mod;",
		  "        b >>= 1;",
		  "    }",
		  "",
		  "    return res;",
		  "}"
		],
		"description": "Binary Exponentiation"
	},

	"Fast Inout" : {
		"prefix": "_fastinout",
		"body": [
		"ios_base::sync_with_stdio(false);",
		"cin.tie(nullptr); cout.tie(nullptr);"
		],
	},

	"Free Opent" : {
		"prefix": "_freeopen",
		"body": [
		"freopen(\"in.txt\", \"r\", stdin);",
		"freopen(\"ou.txt\", \"w\", stdout);"
		],
	},

	"Fenwick Tree Range Range": {
		"prefix": "_ftrangerange",
		"body": [
			"class FenwickTree {",
			"private:",
			"    std::vector<long long> BIT1, BIT2;",
			"",
			"    void update(std::vector<long long> &BIT, int index, long long value) {",
			"        while (index < BIT.size()) {",
			"            BIT[index] += value;",
			"            index += index & (-index);",
			"        }",
			"    }",
			"",
			"    long long query(const std::vector<long long> &BIT, int index) {",
			"        long long sum = 0;",
			"        while (index > 0) {",
			"            sum += BIT[index];",
			"            index -= index & (-index);",
			"        }",
			"        return sum;",
			"    }",
			"",
			"public:",
			"    FenwickTree(int size) : BIT1(size + 1, 0), BIT2(size + 1, 0) {}",
			"",
			"    void rangeUpdate(int left, int right, long long value) {",
			"        update(BIT1, left, value);",
			"        update(BIT1, right + 1, -value);",
			"        update(BIT2, left, value * (left - 1));",
			"        update(BIT2, right + 1, -value * right);",
			"    }",
			"",
			"    long long prefixSum(int index) {",
			"        return query(BIT1, index) * index - query(BIT2, index);",
			"    }",
			"",
			"    long long rangeQuery(int left, int right) {",
			"        return prefixSum(right) - prefixSum(left - 1);",
			"    }",
			"};"
		],
		"description": "Fenwick Tree Range Range"
	},

	"Big Integer": {
		"prefix": "_bigint",
		"body": [
			"struct Bigint",
			"{",
			"    // representations and structures",
			"    string a; // to store the digits",
			"    int sign; // sign = -1 for negative numbers, sign = 1 otherwise",
			"    // constructors",
			"    Bigint() {} // default constructor",
			"    Bigint( string b )",
			"    {",
			"        (*this) = b;    // constructor for string",
			"    }",
			"    // some helpful methods",
			"    int size()   // returns number of digits",
			"    {",
			"        return a.size();",
			"    }",
			"    Bigint inverseSign()   // changes the sign",
			"    {",
			"        sign *= -1;",
			"        return (*this);",
			"    }",
			"    Bigint normalize( int newSign )   // removes leading 0, fixes sign",
			"    {",
			"        for( int i = a.size() - 1; i > 0 && a[i] == '0'; i-- )",
			"            a.erase(a.begin() + i);",
			"        sign = ( a.size() == 1 && a[0] == '0' ) ? 1 : newSign;",
			"        return (*this);",
			"    }",
			"   // assignment operator",
			"    void operator = ( string b )   // assigns a string to Bigint",
			"    {",
			"        a = b[0] == '-' ? b.substr(1) : b;",
			"        reverse( a.begin(), a.end() );",
			"        this->normalize( b[0] == '-' ? -1 : 1 );",
			"    }",
			"    // conditional operators",
			"    bool operator < ( const Bigint &b ) const   // less than operator",
			"    {",
			"        if( sign != b.sign )",
			"            return sign < b.sign;",
			"        if( a.size() != b.a.size() )",
			"            return sign == 1 ? a.size() < b.a.size() : a.size() > b.a.size();",
			"        for( int i = a.size() - 1; i >= 0; i-- )",
			"            if( a[i] != b.a[i] )",
			"                return sign == 1 ? a[i] < b.a[i] : a[i] > b.a[i];",
			"        return false;",
			"    }",
			"    bool operator == ( const Bigint &b ) const   // operator for equality",
			"    {",
			"        return a == b.a && sign == b.sign;",
			"    }",
			"",
			"    // mathematical operators",
			"    Bigint operator + ( Bigint b )   // addition operator overloading",
			"    {",
			"        if( sign != b.sign )",
			"            return (*this) - b.inverseSign();",
			"        Bigint c;",
			"        for(int i = 0, carry = 0; i<a.size() || i<b.size() || carry; i++ )",
			"        {",
			"            carry+=(i<a.size() ? a[i]-48 : 0)+(i<b.a.size() ? b.a[i]-48 : 0);",
			"            c.a += (carry % 10 + 48);",
			"            carry /= 10;",
			"        }",
			"        return c.normalize(sign);",
			"    }",
			"    Bigint operator - ( Bigint b )   // subtraction operator overloading",
			"    {",
			"        if( sign != b.sign )",
			"            return (*this) + b.inverseSign();",
			"        int s = sign;",
			"        sign = b.sign = 1;",
			"        if( (*this) < b )",
			"            return ((b - (*this)).inverseSign()).normalize(-s);",
			"        Bigint c;",
			"        for( int i = 0, borrow = 0; i < a.size(); i++ )",
			"        {",
			"            borrow = a[i] - borrow - (i < b.size() ? b.a[i] : 48);",
			"            c.a += borrow >= 0 ? borrow + 48 : borrow + 58;",
			"            borrow = borrow >= 0 ? 0 : 1;",
			"        }",
			"        return c.normalize(s);",
			"    }",
			"    Bigint operator * ( Bigint b )   // multiplication operator overloading",
			"    {",
			"        Bigint c(\"0\");",
			"        for( int i = 0, k = a[i] - 48; i < a.size(); i++, k = a[i] - 48 )",
			"        {",
			"            while(k--)",
			"                c = c + b; // ith digit is k, so, we add k times",
			"            b.a.insert(b.a.begin(), '0'); // multiplied by 10",
			"        }",
			"        return c.normalize(sign * b.sign);",
			"    }",
			"    Bigint operator / ( Bigint b )   // division operator overloading",
			"    {",
			"        if( b.size() == 1 && b.a[0] == '0' )",
			"            b.a[0] /= ( b.a[0] - 48 );",
			"        Bigint c(\"0\"), d;",
			"        for( int j = 0; j < a.size(); j++ )",
			"            d.a += \"0\";",
			"        int dSign = sign * b.sign;",
			"        b.sign = 1;",
			"        for( int i = a.size() - 1; i >= 0; i-- )",
			"        {",
			"            c.a.insert( c.a.begin(), '0');",
			"            c = c + a.substr( i, 1 );",
			"            while( !( c < b ) )",
			"                c = c - b, d.a[i]++;",
			"        }",
			"        return d.normalize(dSign);",
			"    }",
			"    Bigint operator % ( Bigint b )   // modulo operator overloading",
			"    {",
			"        if( b.size() == 1 && b.a[0] == '0' )",
			"            b.a[0] /= ( b.a[0] - 48 );",
			"        Bigint c(\"0\");",
			"        b.sign = 1;",
			"        for( int i = a.size() - 1; i >= 0; i-- )",
			"        {",
			"            c.a.insert( c.a.begin(), '0');",
			"            c = c + a.substr( i, 1 );",
			"            while( !( c < b ) )",
			"                c = c - b;",
			"        }",
			"        return c.normalize(sign);",
			"    }",
			"",
			"    // output method",
			"    void print()",
			"    {",
			"        if( sign == -1 )",
			"            putchar('-');",
			"        for( int i = a.size() - 1; i >= 0; i-- )",
			"            putchar(a[i]);",
			"        putchar('\\n');",
			"    }",
			"};"
		],
		"description": "Fenwick Tree Range Range"
	},

	"Euler Tour": {
		"prefix": "_eulertour",
		"body": [
			"vector<vector<int>> adj;",
			"vector<int> startIdx, endIdx;",
			"int timer = 0;",
			"",
			"void euler_tour(int at, int prev) {",
			"    startIdx[at] = timer++;",
			"    for (int n : adj[at]) {",
			"        if (n != prev) { euler_tour(n, at); }",
			"    }",
			"    endIdx[at] = timer;",
			"}"
		],
		"description": "Euler Tour"
	}
}
