{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Template": {
		"prefix": "_template",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define int long long",
			"",
			"int32_t main() {",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr); cout.tie(nullptr);",
			"",
			"    #ifdef LOCAL",
			"        freopen(\"in.txt\", \"r\", stdin);",
			"        freopen(\"ou.txt\", \"w\", stdout);",
			"    #endif",
			"",
			"    return 0;",
			"}"
		]
	},
	
	"Segment Tree": {
		"prefix": "_segmenttree",
		"body": [
		  "class SegmentTree {",
		  "private:",
		  "    int n;",
		  "    vector<int> tree;",
		  "",
		  "    int merge(int a, int b) {",
		  "        return max(a, b);",
		  "    }",
		  "",
		  "    void update(int node, int tl, int tr, int pos, int val) {",
		  "        if (tl == tr) {",
		  "            tree[node] += val;",
		  "        } else {",
		  "            int tm = (tl + tr) / 2;",
		  "            if (pos <= tm)",
		  "                update(node*2, tl, tm, pos, val);",
		  "            else",
		  "                update(node*2+1, tm+1, tr, pos, val);",
		  "            tree[node] = merge(tree[node*2], tree[node*2+1]);",
		  "        }",
		  "    }",
		  "",
		  "    int query(int node, int tl, int tr, int l, int r) {",
		  "        if (l > r) return 0;",
		  "        if (l == tl && r == tr) {",
		  "            return tree[node];",
		  "        }",
		  "        int tm = (tl + tr) / 2;",
		  "        return merge(query(node*2, tl, tm, l, min(r, tm)),",
		  "               query(node*2+1, tm+1, tr, max(l, tm+1), r));",
		  "    }",
		  "",
		  "public:",
		  "    SegmentTree(int sz) : n(sz) {",
		  "        tree.assign(4 * n, 0);",
		  "    }",
		  "",
		  "    void update(int pos, int val) {",
		  "        update(1, 1, n, pos, val);",
		  "    }",
		  "",
		  "    int query(int l, int r) {",
		  "        return query(1, 1, n, l, r);",
		  "    }",
		  "};"
		],
		"description": "Segment Tree"
	},

	"Matrix": {
		"prefix": "_matrix",
		"body": [
		  "struct Matrix {",
		  "    vector<vector<long long>> mat;",
		  "    int n_rows, n_cols;",
		  "",
		  "    Matrix(int n_rows, int n_cols) : n_rows(n_rows), n_cols(n_cols) {",
		  "        mat.resize(n_rows, vector<long long>(n_cols, 0));",
		  "    }",
		  "",
		  "    static Matrix identity_matrix(int n) {",
		  "        Matrix I(n, n);",
		  "        for (int i = 0; i < n; i++) {",
		  "            I.mat[i][i] = 1;",
		  "        }",
		  "        return I;",
		  "    }",
		  "",
		  "    Matrix operator*(const Matrix &other) const {",
		  "        int n = n_rows, m = other.n_cols;",
		  "        Matrix result(n, m);",
		  "        for (int i = 0; i < n; i++) {",
		  "            for (int j = 0; j < m; j++) {",
		  "                for (int k = 0; k < n_cols; k++) {",
		  "                    result.mat[i][j] += mat[i][k] * other.mat[k][j];",
		  "                    result.mat[i][j] %= MOD;",
		  "                }",
		  "            }",
		  "        }",
		  "        return result;",
		  "    }",
		  "",
		  "    Matrix pow(long long power) const {",
		  "        Matrix result = identity_matrix(n_rows);",
		  "        Matrix base = *this;",
		  "        while (power > 0) {",
		  "            if (power & 1) {",
		  "                result = result * base;",
		  "            }",
		  "            base = base * base;",
		  "            power >>= 1;",
		  "        }",
		  "        return result;",
		  "    }",
		  "};",
		  "",
		  "long long calculate_Gn(long long n, int c, int d) {",
		  "    Matrix trans(2, 2);",
		  "    trans.mat = {{1, 2}, {1, 0}};",
		  "",
		  "    Matrix state(2, 1);",
		  "    state.mat = {{c}, {d}};",
		  "",
		  "    state = trans.pow(n - 1) * state;",
		  "",
		  "    return state.mat[0][0];",
		  "}"
		],
		"description": "Matrix"
	  },

	"Disjoin Set Union": {
		"prefix": "_dsu",
		"body": [
		  "class UnionFind {",
		  "private:",
		  "    vector<int> p, rank, setSize;",
		  "    int numSets;",
		  "",
		  "public:",
		  "    UnionFind(int N)",
		  "    {",
		  "        p.assign(N, 0);",
		  "        for (int i = 0; i < N; ++i)",
		  "            p[i] = i;",
		  "        rank.assign(N, 0);",
		  "        setSize.assign(N, 1);",
		  "        numSets = N;",
		  "    }",
		  "    int findSet(int i) { return (p[i] == i) ? i : (p[i] = findSet(p[i])); }",
		  "    bool isSameSet(int i, int j) { return findSet(i) == findSet(j); }",
		  "    int numDisjointSets() { return numSets; }",
		  "    int sizeOfSet(int i) { return setSize[findSet(i)]; }",
		  "    void unionSet(int i, int j)",
		  "    {",
		  "        if (isSameSet(i, j))",
		  "            return;",
		  "        int x = findSet(i), y = findSet(j);",
		  "        if (rank[x] > rank[y])",
		  "            swap(x, y);",
		  "        p[x] = y;",
		  "        if (rank[x] == rank[y])",
		  "            ++rank[y];",
		  "        setSize[y] += setSize[x];",
		  "        --numSets;",
		  "    }",
		  "};"
		],
		"description": "Disjoin Set Union"
	  },

	"Segment Tree Greater": {
		  "prefix": "_stgreater",
		  "body": [
		    "// https://codeforces.com/contest/459/problem/D",
		    "",
		    "#include <bits/stdc++.h>",
		    "using namespace std;",
		    "",
		    "class SegmentTree {",
		    "private:",
		    "    vector<vector<int>> tree;",
		    "    int n;",
		    "",
		    "    void build(const vector<int>& arr, int node, int start, int end) {",
		    "        if (start == end) {",
		    "            tree[node] = { arr[start] };",
		    "        } else {",
		    "            int mid = (start + end) / 2;",
		    "            int leftChild = 2 * node + 1;",
		    "            int rightChild = 2 * node + 2;",
		    "            build(arr, leftChild, start, mid);",
		    "            build(arr, rightChild, mid + 1, end);",
		    "            merge(tree[leftChild].begin(), tree[leftChild].end(),",
		    "                  tree[rightChild].begin(), tree[rightChild].end(),",
		    "                  back_inserter(tree[node]));",
		    "        }",
		    "    }",
		    "",
		    "    int query(int node, int start, int end, int l, int r, int x) {",
		    "        if (r < start || end < l) {",
		    "            return 0;",
		    "        }",
		    "        if (l <= start && end <= r) {",
		    "            return tree[node].end() - upper_bound(tree[node].begin(), tree[node].end(), x);",
		    "        }",
		    "        int mid = (start + end) / 2;",
		    "        int leftChild = 2 * node + 1;",
		    "        int rightChild = 2 * node + 2;",
		    "        return query(leftChild, start, mid, l, r, x) + query(rightChild, mid + 1, end, l, r, x);",
		    "    }",
		    "",
		    "public:",
		    "    SegmentTree(const vector<int>& arr) {",
		    "        n = arr.size();",
		    "        tree.resize(4 * n);",
		    "        build(arr, 0, 0, n - 1);",
		    "    }",
		    "",
		    "    int query(int l, int r, int x) {",
		    "        return query(0, 0, n - 1, l, r, x);",
		    "    }",
		    "};",
		    "",
		    "int32_t main() {",
		    "    ios_base::sync_with_stdio(false);",
		    "    cin.tie(nullptr); cout.tie(nullptr);",
		    "",
		    "    #ifdef LOCAL",
		    "        freopen(\"in.txt\", \"r\", stdin);",
		    "        freopen(\"ou.txt\", \"w\", stdout);",
		    "    #endif",
		    "",
		    "    int n; cin >> n;",
		    "    vector<int> arr(n);",
		    "",
		    "    unordered_map<int, int> cnt;",
		    "    int trace2[n+1];",
		    "    vector<int> trace1(n+1);",
		    "    for (int i=0; i<n; i++) {",
		    "        cin >> arr[i];",
		    "        cnt[arr[i]]++;",
		    "        trace1[i] = cnt[arr[i]];",
		    "    }",
		    "",
		    "    for (int i=0; i<n; i++) {",
		    "        trace2[i] = cnt[arr[i]];",
		    "        cnt[arr[i]]--;",
		    "        if (cnt[arr[i]] == 0) cnt.erase(arr[i]);",
		    "    }",
		    "",
		    "    cnt.clear();",
		    "",
		    "    SegmentTree segTree(trace1);",
		    "    long long res = 0LL;",
		    "    for (int i=n-1; i>=0; i--) {",
		    "        long long tmp = segTree.query(0, i-1, trace2[i]);",
		    "        res += tmp;",
		    "    }",
		    "",
		    "    cout << res << endl;",
		    "",
		    "    return 0;",
		    "}"
		  ],
		  "description": "Segment Tree Greater"
	},

	"Fenwick Tree": {
		"prefix": "_fenwick_tree",
		"body": [
		  "class FenwickTree {",
		  "public:",
		  "    FenwickTree(int n) {",
		  "        this->n = n;",
		  "        ft.assign(n, 0);",
		  "    }",
		  "",
		  "    FenwickTree(vector<int> arr) : FenwickTree(arr.size()) {",
		  "        for (int i=0; i<arr.size(); i++)",
		  "            add(i, arr[i]);",
		  "    }",
		  "",
		  "    int query(int l, int r) {",
		  "        return sum(r) - sum(l-1);",
		  "    }",
		  "",
		  "    void add(int idx, int vl) {",
		  "        for (; idx < n; idx = idx | (idx + 1))",
		  "            ft[idx] += vl;",
		  "    }",
		  "",
		  "private:",
		  "    vector<int> ft;",
		  "    int n;",
		  "",
		  "private:",
		  "    int g(int i) { return i & (i + 1); }",
		  "    int sum(int i) {",
		  "        int rs = 0;",
		  "        while (i >= 0) {",
		  "            rs += ft[i];",
		  "            i = g(i) - 1;",
		  "        }",
		  "        return rs;",
		  "    }",
		  "};",
		],
		"description": "Segment Tree"
	},

	"Segment Tree Lazy Update": {
		"prefix": "_lazy_segment_tree",
		"body": [
		  "class SegmentTree { // 1-based index sum segment tree",
		  "private:",
		  "    int n, tree[MAXN*4], lazy[MAXN*4];",
		  "    vector<int> arr;",
		  "",
		  "    void build(int node, int tl, int tr) {",
		  "        if (tl == tr) tree[node] = arr[tl];",
		  "        else {",
		  "            int tm = (tl + tr) >> 1;",
		  "            build(node*2, tl, tm);",
		  "            build(node*2+1, tm+1, tr);",
		  "            tree[node] = tree[node*2] + tree[node*2+1];",
		  "        }",
		  "    }",
		  "",
		  "    int query(int node, int l, int r, int tl, int tr) {",
		  "        if (l > r) return 0;",
		  "        if (l == tl && r == tr) return tree[node];",
		  "        push(node);",
		  "        int tm = (tl + tr) >> 1;",
		  "        return query(node*2, l, min(r, tm), tl, tm) + query(node*2+1, max(l, tm+1), r, tm+1, tr);",
		  "    }",
		  "",
		  "    void push(int node) {",
		  "        if (lazy[node]) {",
		  "            tree[node*2] = tree[node*2+1] = tree[node];",
		  "            lazy[node*2] = lazy[node*2+1] = true;",
		  "            lazy[node] = false;",
		  "        }",
		  "    }",
		  "",
		  "    void update(int node, int pos, int tl, int tr, int val) {",
		  "        if (tl == tr) tree[node] = val;",
		  "        else {",
		  "            int tm = (tl + tr) >> 1;",
		  "",
		  "            if (pos <= tm) update(node*2, pos, tl, tm, val);",
		  "            else update(node*2+1, pos, tm+1, tr, val);",
		  "",
		  "            tree[node] = tree[node*2] + tree[node*2+1];",
		  "        }",
		  "    }",
		  "",
		  "    void rangeUpdate(int node, int l, int r, int tl, int tr, int val) {",
		  "        if (l > r) return;",
		  "        if (l == tl && r == tr) {",
		  "            tree[node] = val;",
		  "            lazy[node] = true;",
		  "        } else {",
		  "            push(node);",
		  "            int tm = (tl + tr) >> 1;",
		  "            rangeUpdate(node*2, l, min(r, tm), tl, tm, val);",
		  "            rangeUpdate(node*2+1, max(l, tm+1), r, tm+1, tr, val);",
		  "        }",
		  "    }",
		  "",
		  "public:",
		  "    SegmentTree(int sz) {",
		  "        n = sz;",
		  "        arr.resize(n+5, 0);",
		  "    }",
		  "",
		  "    int query(int l, int r) {",
		  "        return query(1, l, r, 1, n);",
		  "    }",
		  "",
		  "    void update(int pos, int val) {",
		  "        update(1, pos, 1, n, val);",
		  "    }",
		  "",
		  "    void rangeUpdate(int l, int r, int val) {",
		  "        rangeUpdate(1, l, r, 1, n, val);",
		  "    }",
		  "};"
		],
		"description": "Segment Tree Lazy Update"
	},

	"Segment Tree Range Query Without Lazy": {
		  "prefix": "_strange",
		  "body": [
		    "class SegmentTree { // 1-based index sum segment tree",
		    "private:",
		    "    int n, tree[MAXN*4];",
		    "    vector<int> arr;",
		    "",
		    "    void build(int node, int tl, int tr) {",
		    "        if (tl == tr) tree[node] = arr[tl];",
		    "        else {",
		    "            int tm = (tl + tr) >> 1;",
		    "            build(node*2, tl, tm);",
		    "            build(node*2+1, tm+1, tr);",
		    "            tree[node] = tree[node*2] + tree[node*2+1];",
		    "        }",
		    "    }",
		    "",
		    "    int query(int node, int l, int r, int tl, int tr) {",
		    "        if (l > r) return 0;",
		    "        if (l == tl && r == tr) return tree[node];",
		    "        int tm = (tl + tr) >> 1;",
		    "        return query(node*2, l, min(r, tm), tl, tm) + query(node*2+1, max(l, tm+1), r, tm+1, tr);",
		    "    }",
		    "",
		    "    void update(int node, int pos, int tl, int tr, int val) {",
		    "        if (tl == tr) tree[node] = val;",
		    "        else {",
		    "            int tm = (tl + tr) >> 1;",
		    "",
		    "            if (pos <= tm) update(node*2, pos, tl, tm, val);",
		    "            else update(node*2+1, pos, tm+1, tr, val);",
		    "",
		    "            tree[node] = tree[node*2] + tree[node*2+1];",
		    "        }",
		    "    }",
		    "",
		    "    void rangeUpdate(int node, int l, int r, int tl, int tr, int val) {",
		    "        if (l > r) return;",
		    "        if (tl == tr) {",
		    "            tree[node] = val;",
		    "        }",
		    "        else {",
		    "            int tm = (tl + tr) >> 1;",
		    "            rangeUpdate(node*2, l, min(r, tm), tl, tm, val);",
		    "            rangeUpdate(node*2+1, max(l, tm+1), r, tm+1, tr, val);",
		    "",
		    "            tree[node] = tree[node*2] + tree[node*2+1];",
		    "        }",
		    "    }",
		    "",
		    "public:",
		    "    SegmentTree(int sz) {",
		    "        n = sz;",
		    "        arr.resize(n+5, 0);",
		    "    }",
		    "",
		    "    int query(int l, int r) {",
		    "        return query(1, l, r, 1, n);",
		    "    }",
		    "",
		    "    void update(int pos, int val) {",
		    "        update(1, pos, 1, n, val);",
		    "    }",
		    "",
		    "    void rangeUpdate(int l, int r, int val) {",
		    "        rangeUpdate(1, l, r, 1, n, val);",
		    "    }",
		    "};"
		  ],
		  "description": "Segment Tree Range Query Without Lazy"
	},	

	"Difference Array": {
		"prefix": "_diff_array",
		"body": [
		  "#ifndef MAXN",
		  "#define MAXN 200100",
		  "#endif",
		  "",
		  "int n, arr[MAXN], diff[MAXN];",
		  "",
		  "void update(int l, int r, int vl) {",
		  "    diff[l] += vl;",
		  "    if (r + 1 < n) diff[r] -= vl;",
		  "}",
		  "",
		  "void apply_update()",
		  "{",
		  "    /*",
		  "    // update the value of arr by the prefix sum of diff",
		  "    */",
		  "    for (int i=0; i<n; i++) diff[i] += diff[i-1];",
		  "    for (int i=0; i<n; i++) arr[i] += diff[i]; ",
		  "}"
		],
		"description": "Difference Array"
	},

	"For loop": {
		"prefix": "_for",
		"body": [
			"for (int i=0; i<n; i++) {}",
		],
		"description": "Loop For"
	},

	"Binary Exponentiation": {
		"prefix": "_binpow",
		"body": [
		  "int binpow(int a, int b, int mod) {",
		  "    if (a == 0) return 0;",
		  "    if (b == 1) return a;",
		  "",
		  "    int res = 1;",
		  "    while (b) {",
		  "        if (b & 1) res = (res * a) % mod;",
		  "        a = a * a % mod;",
		  "        b >>= 1;",
		  "    }",
		  "",
		  "    return res;",
		  "}"
		],
		"description": "Binary Exponentiation"
	},

	"Fast Inout" : {
		"prefix": "_fastinout",
		"body": [
		"ios_base::sync_with_stdio(false);",
		"cin.tie(nullptr); cout.tie(nullptr);"
		],
	},

	"FreOpen" : {
		"prefix": "_freopen",
		"body": [
		"#ifdef LOCAL",
		"    freopen(\"in.txt\", \"r\", stdin);",
		"    freopen(\"ou.txt\", \"w\", stdout);",
		"#endif"
		],
	},

	"Fenwick Tree Range Range": {
		"prefix": "_ftrangerange",
		"body": [
			"class FenwickTree {",
			"private:",
			"    std::vector<long long> BIT1, BIT2;",
			"",
			"    void update(std::vector<long long> &BIT, int index, long long value) {",
			"        while (index < BIT.size()) {",
			"            BIT[index] += value;",
			"            index += index & (-index);",
			"        }",
			"    }",
			"",
			"    long long query(const std::vector<long long> &BIT, int index) {",
			"        long long sum = 0;",
			"        while (index > 0) {",
			"            sum += BIT[index];",
			"            index -= index & (-index);",
			"        }",
			"        return sum;",
			"    }",
			"",
			"public:",
			"    FenwickTree(int size) : BIT1(size + 1, 0), BIT2(size + 1, 0) {}",
			"",
			"    void rangeUpdate(int left, int right, long long value) {",
			"        update(BIT1, left, value);",
			"        update(BIT1, right + 1, -value);",
			"        update(BIT2, left, value * (left - 1));",
			"        update(BIT2, right + 1, -value * right);",
			"    }",
			"",
			"    long long prefixSum(int index) {",
			"        return query(BIT1, index) * index - query(BIT2, index);",
			"    }",
			"",
			"    long long rangeQuery(int left, int right) {",
			"        return prefixSum(right) - prefixSum(left - 1);",
			"    }",
			"};"
		],
		"description": "Fenwick Tree Range Range"
	},

	"Big Integer": {
		"prefix": "_bigint",
		"body": [
			"struct Bigint",
			"{",
			"    // representations and structures",
			"    string a; // to store the digits",
			"    int sign; // sign = -1 for negative numbers, sign = 1 otherwise",
			"    // constructors",
			"    Bigint() {} // default constructor",
			"    Bigint( string b )",
			"    {",
			"        (*this) = b;    // constructor for string",
			"    }",
			"    // some helpful methods",
			"    int size()   // returns number of digits",
			"    {",
			"        return a.size();",
			"    }",
			"    Bigint inverseSign()   // changes the sign",
			"    {",
			"        sign *= -1;",
			"        return (*this);",
			"    }",
			"    Bigint normalize( int newSign )   // removes leading 0, fixes sign",
			"    {",
			"        for( int i = a.size() - 1; i > 0 && a[i] == '0'; i-- )",
			"            a.erase(a.begin() + i);",
			"        sign = ( a.size() == 1 && a[0] == '0' ) ? 1 : newSign;",
			"        return (*this);",
			"    }",
			"   // assignment operator",
			"    void operator = ( string b )   // assigns a string to Bigint",
			"    {",
			"        a = b[0] == '-' ? b.substr(1) : b;",
			"        reverse( a.begin(), a.end() );",
			"        this->normalize( b[0] == '-' ? -1 : 1 );",
			"    }",
			"    // conditional operators",
			"    bool operator < ( const Bigint &b ) const   // less than operator",
			"    {",
			"        if( sign != b.sign )",
			"            return sign < b.sign;",
			"        if( a.size() != b.a.size() )",
			"            return sign == 1 ? a.size() < b.a.size() : a.size() > b.a.size();",
			"        for( int i = a.size() - 1; i >= 0; i-- )",
			"            if( a[i] != b.a[i] )",
			"                return sign == 1 ? a[i] < b.a[i] : a[i] > b.a[i];",
			"        return false;",
			"    }",
			"    bool operator == ( const Bigint &b ) const   // operator for equality",
			"    {",
			"        return a == b.a && sign == b.sign;",
			"    }",
			"",
			"    // mathematical operators",
			"    Bigint operator + ( Bigint b )   // addition operator overloading",
			"    {",
			"        if( sign != b.sign )",
			"            return (*this) - b.inverseSign();",
			"        Bigint c;",
			"        for(int i = 0, carry = 0; i<a.size() || i<b.size() || carry; i++ )",
			"        {",
			"            carry+=(i<a.size() ? a[i]-48 : 0)+(i<b.a.size() ? b.a[i]-48 : 0);",
			"            c.a += (carry % 10 + 48);",
			"            carry /= 10;",
			"        }",
			"        return c.normalize(sign);",
			"    }",
			"    Bigint operator - ( Bigint b )   // subtraction operator overloading",
			"    {",
			"        if( sign != b.sign )",
			"            return (*this) + b.inverseSign();",
			"        int s = sign;",
			"        sign = b.sign = 1;",
			"        if( (*this) < b )",
			"            return ((b - (*this)).inverseSign()).normalize(-s);",
			"        Bigint c;",
			"        for( int i = 0, borrow = 0; i < a.size(); i++ )",
			"        {",
			"            borrow = a[i] - borrow - (i < b.size() ? b.a[i] : 48);",
			"            c.a += borrow >= 0 ? borrow + 48 : borrow + 58;",
			"            borrow = borrow >= 0 ? 0 : 1;",
			"        }",
			"        return c.normalize(s);",
			"    }",
			"    Bigint operator * ( Bigint b )   // multiplication operator overloading",
			"    {",
			"        Bigint c(\"0\");",
			"        for( int i = 0, k = a[i] - 48; i < a.size(); i++, k = a[i] - 48 )",
			"        {",
			"            while(k--)",
			"                c = c + b; // ith digit is k, so, we add k times",
			"            b.a.insert(b.a.begin(), '0'); // multiplied by 10",
			"        }",
			"        return c.normalize(sign * b.sign);",
			"    }",
			"    Bigint operator / ( Bigint b )   // division operator overloading",
			"    {",
			"        if( b.size() == 1 && b.a[0] == '0' )",
			"            b.a[0] /= ( b.a[0] - 48 );",
			"        Bigint c(\"0\"), d;",
			"        for( int j = 0; j < a.size(); j++ )",
			"            d.a += \"0\";",
			"        int dSign = sign * b.sign;",
			"        b.sign = 1;",
			"        for( int i = a.size() - 1; i >= 0; i-- )",
			"        {",
			"            c.a.insert( c.a.begin(), '0');",
			"            c = c + a.substr( i, 1 );",
			"            while( !( c < b ) )",
			"                c = c - b, d.a[i]++;",
			"        }",
			"        return d.normalize(dSign);",
			"    }",
			"    Bigint operator % ( Bigint b )   // modulo operator overloading",
			"    {",
			"        if( b.size() == 1 && b.a[0] == '0' )",
			"            b.a[0] /= ( b.a[0] - 48 );",
			"        Bigint c(\"0\");",
			"        b.sign = 1;",
			"        for( int i = a.size() - 1; i >= 0; i-- )",
			"        {",
			"            c.a.insert( c.a.begin(), '0');",
			"            c = c + a.substr( i, 1 );",
			"            while( !( c < b ) )",
			"                c = c - b;",
			"        }",
			"        return c.normalize(sign);",
			"    }",
			"",
			"    // output method",
			"    void print()",
			"    {",
			"        if( sign == -1 )",
			"            putchar('-');",
			"        for( int i = a.size() - 1; i >= 0; i-- )",
			"            putchar(a[i]);",
			"        putchar('\\n');",
			"    }",
			"};"
		],
		"description": "Fenwick Tree Range Range"
	},

	"Euler Tour": {
		"prefix": "_eulertour",
		"body": [
			"vector<vector<int>> adj;",
			"vector<int> startIdx, endIdx;",
			"int timer = 0;",
			"",
			"void euler_tour(int at, int prev) {",
			"    startIdx[at] = timer++;",
			"    for (int n : adj[at]) {",
			"        if (n != prev) { euler_tour(n, at); }",
			"    }",
			"    endIdx[at] = timer;",
			"}"
		],
		"description": "Euler Tour"
	}
}
